package bit_operation

// 为什么 N^ & (^N+1) 获取的二进制最右侧 1 位值
// 因为取反+1 永远是他的负值
// 正因为是有 + 1 的这个操作 二进制 + 的时候 才会保持正确性
// 既然是加 + 1 那必然原码的最右侧必然有一位是 1 + 正好抵消
// &的操作实际上就是为了确定 + 1 的那一位具体是哪一位
// 具体可参考 计算机 ： 原码 反码 补码  二进制加法实现 二进制减法实现  （减法的原理实际上是参考了 同余定理）
func rightBit(n uint8) (bit uint8) {
	bit = n & (^n + 1)
	return
}
